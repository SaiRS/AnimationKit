# 模型树和呈现树的思考

标签: `模型树`， `呈现树`，`动画`， `动画参数`

## 问题来源

在子类XXNodeDomActor的实现过程中，scaleTo，rotateTo均是采用修改css('transform')的属性来达到目的的，这个方法会覆盖之前的'transform'的信息，结果就是我们必须记录之前的一系列transform的操作，然后再和当前的变化组合起来形成新的transorms操作。而动画的执行过程中，我们却不能在每一次的update()函数中去同步更新transforms的组合，原因如下

* **在动画进行过程中，我们需要记录一个初始化的对象的transform，动画的所有变化都是在这个初始化的transform之上进行变化，但这个初始的transform并不是实时的模型树**。比如说初始的transforms为[]，我们要执行scaleTo(2,2)，每次delta为0.2，则第一次调用scaleTo的参数为scaleTo(new XXScale(0.2, 0.2))，第二次的调用为scaleTo(new XXScale(0.4, 0.4))，我们的出发点是动画执行前的那个状态，所以实时更新的后果就是将原本应该是（0.4，0.4）的缩放量变成了（0.2，0.2）*（0.4，0.4）=（0.08,0.08)，与实际不符至于我们为什么每次计算都采用动画执行前的那个状态而不是动画的上一个状态，是因为那样子更简单，将整个过程看作是0-1的过程，对于执行ease，控制播放都方便很多。基于上面的原因，在执行动画的过程中，自然就造成了模型树和呈现树的分离。

## 解决办法

1. 将物体的模型和呈现分开。
2. 动画开始时，获取当前物体的模型树属性，当作初始的transfroms
3. 动画过程中，用初始transform去处理scale, rotate等操作
4. 动画完成后，更新模型树为当前状态

## 产生的问题

1. 动画结束后，是否更新模型树为当前状态需要通过action的选项去控制，思路参考```css transition fillMode```，这个简单，加上一个判断条件就行

   ```javascript
   if ('forward' === fillMode) {
      // 更新模型树，使与呈现树一致 
   } else if ('backward' === fillMode) {
      // 更新呈现树，使与模型树一致
   }
   ```

2. 如果增加了```fillMode```，对于按顺序执行的```sequenceAction```的```fillMode```跟sequence里边每个action的```fillMode```冲突怎么解决？

   1. 因为是连续执行，所以不管单个action的fillMode，在单个action执行完之后，全部更新模型树
   2. ​

3. 对于同时修改的```spawnAction```来说，效果跟我们预想的效果不一致。比如说scaleTo, rotateTo组合，其实状态两者的初始transform都一样，先执行scaleTo，只修改了呈现树，再执行rotateTo，则会覆盖scaleTo的效果，下一次调用```step```函数时，scaleTo又会覆盖rotateTo的效果。

   1. 不在记录transforms的值，而是记录```T(translate), R(rotate), S(scale)```的值，通过```TRS```组合构成transform。
   2. 顺序```TRS```，表示左乘。先缩放，再旋转，最后平移。
   3. 因为矩阵的乘法不满足交换律，所以之后所有的操作顺序都需要严格按照这个顺序进行。
   4. `取消呈现和模型树的设计`

## 最终方案

1. 取消呈现和模型树的设计

2. 所有的操作按照```TRS```顺序

   ​

> css transform的应用顺序是从右到左， 比如说```    transform: rotate(23deg) translate(20px, 14px)```表示先平移，后旋转
>
> 在matrix中也用从右到左的顺序表示，（x，y，z）是列向量，应用于matrix的左乘



