

1. **时间**：2017.9.25

   **问题**：加载```iView```组件的```css```文件时，postCSS-loader报错。

   **原因**：postCSS-loader的autoPrefixer组件名字写错了。

2. **时间**：2017.9.28

   **问题**：js文件中怎么使用图片资源？

   **方法**：

   ```javascript
   import imageName from 'path'

   let img = document.createElement('img');
   img.src = imageName;
   ```

3. **时间**：2017.9.29

   **问题**：怎么使用webpack进行动态加载呢？

   **方法**：

4. 时间：2017.10.5

   问题：怎么去除js，和vue中的console语句

   方法：通过```UglifyJsPlugin```

   ```javascript
       new webpack.optimize.UglifyJsPlugin({
         compress: {
           warnings: false,
           drop_debugger: true,
           drop_console: true,
         },
       }),
   ```

5. 时间：2017.10.7

   问题：vue-loader好像不会对```<script>块```进行babel操作

   方法：

   ```javascript
         {
           test: /\.vue$/,
           exclude: /node_modules/,
           use: [
             {
               loader: 'vue-loader',
               options: {
                 loaders: {
                   js: [
                       {
                         enforce: 'pre',
                         loader: 'eslint-loader',
                       },
                       {
                         loader: 'babel-loader',
                         options: {
                           babelrc: true,
                           extends: path.resolve(__dirname, '.babelrc'),
                         },
                       },
                   ],
                   css: appVueCSSExtract.extract({
                     fallback: 'vue-style-loader',
                     use: [
                     {
                       loader: 'css-loader',
                       options: {
                         sourceMap: true,
                       },
                     }, {
                       loader: 'postcss-loader',
                       options: {
                         config: {
                           path: path.resolve(__dirname, 'postcss.config.js'),
                         },
                         sourceMap: true,
                       },
                     }],
                   }),
                 },
               },
             },
           ],
         },
   ```

6. 时间：2017.10.16

   问题： Vue中计算属性的书写？

   ```javascript
   // 一
   computed: {
     bottomBorderColor: () => {
     	return '#000'
     },
     
     styleObject: function() {
       return {
       	left: 100 + 'px',
       	'background-color': this.background,
     	}
     }
   }

   // 二
   ...
     styleObject: () => {
       return {
       	left: 100 + 'px',
       	'background-color': this.background,
     	}
     }
     
     // 用一的写法是我们预期的效果，而采用箭头函数则不行
   ```

   原因：使用普通函数，能正确识别this，而箭头函数则不能。可能是Vue本身处理的问题，我们应该使用`普通函数的表示来书写`

7. 时间：10.23

   问题：如何在项目中的js文件中使用自定义的如```process.env.Mock```参数

   方法：

   ```javascript
   // 通过使用DefinePlugin来让其余的js文件能使用process.evn.Mock  
   plugins: [
       new webpack.DefinePlugin({
         // Definitions...
         'process.env': {
           Mock: true,
         },
       }),
     ],
   ```

8. **时间**：10.30

   **问题**：如何表示当前选中的对象？

   **问题由来**：在编辑中，需要获取当前选中的对象，才能进行下一步操作。但这个对象不一定只是一个对象，可能会是多个对象的集合（组），所以之前想用纯数据来表示这个信息看起来不太方便（比如组里边的集合的属性怎么获取，怎么修改）。但是如果使用对象（组也看成是一个对象），这个对象应该是什么？VUE对象么？

   **解决办法**：

   ```
   仍然传数据，但是需要增加一些解析，设置数据的工具类。
   因为Vue作为数据驱动，直接修改数据，视图会跟着变化，如果传入一个我们自己构造的对象，本质上也是操作数据，而且在store那边依旧需要有对象（组对象）来记录传过来的数据，显得多此一举。
   ```

9. webpack url-loader已经变成了base64,但是设置为background-image一直没显示？

   ​

10. 在vue-router的component属性是，使用require('...')会出错(提示template或者render没有找到)，而改用import则不会？

11. mock不能拦截jsonp的请求。

12. ```jSon
   nodeGraph: {
     properties: [
       {
         type: background,
         value: {
           backgroundColor: ***
           backgroundImage: {
             type: linear-gradient,
             value: {
               angle: ***
               fromColor: ***,
               endColor: ***
             }
           }
         }
       }
     ]
   }

   // 当backgroundImage为null,重新设置一个新的对象给backgroundImage时，计算属性backgroundImage,backgroundFromColor, backgroundEndColor, backgroundAngle都能更新，而当第二次修改时（取得backgroundImage, 并重新设置其属性的值），backgroundImage内容更新了，但其他的计算属性并没有更新？
   所以问题是：vue到底怎么触发computed计算的？
   ```

13. 注意在vue中，对象新增属性／数组新增元素，要新增后的属性／元素也是reactive的，则需要保证我们的新增操作会触发defineProperty的set方法，最简单的就是，重新将整个对象／数组赋值。

    ```js
    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);[
      'push',
      'pop',
      'shift',
      'unshift',
      'splice',
      'sort',
      'reverse'
    ]
    ```


    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);[
      'push',
      'pop',
      'shift',
      'unshift',
      'splice',
      'sort',
      'reverse'
    ]
    .forEach(function (method) {
      // cache original method
      var original = arrayProto[method];
      def(arrayMethods, method, function mutator () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];
    
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
          case 'push':
          case 'unshift':
            inserted = args;
            break
          case 'splice':
            inserted = args.slice(2);
            break
        }
        if (inserted) { ob.observeArray(inserted); }
        // notify change
        ob.dep.notify();
        return result
      });
    });
> 上面代码是vue源码中对于数组方法的扩展，所以之前我以为对于数组添加新元素一定要重新赋值的想法是错的，直接调用push，unshift也会触发ob.observeArray()方法

14. 针对vue中，computed的属性也已可以使用其他computed的属性的情况，如何reactive？

    ```
    我们提供的函数, 会当成expression变量，最终生成getter方法存放在Watcher中。
    同时Watcher中有一个get方法，除了调用getter方法之外，get函数会调用pushTarget, popTarget来建立Dep.target的栈，并更新Dep.target。
    Vue使用Object.defineProperty重新定义了我们的computed属性，对应的函数为createComputedGetter, 在这个函数里边找到对应的Watcher, 并调用get方法，然后执行
          if (Dep.target) {
            watcher.depend();
          }
    其中，watcher.depend是将watcher所有的dep与当前Dep.target（也就是另一个watcher）相关联。
    ```

    图例：

    ​