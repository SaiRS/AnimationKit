## Move

> 一个对象的时间线动画
>
> 对象属性设置和动画的属性设置分开

### 关键帧

> 链式构造确实很简洁优雅

* 设置绝对状态(transition)
  * ```set(property, value)```
* 相对于当前状态的该变量(transition)
  * ```add(property, value)```
  * ```sub(property, value)```
* 旋转(transform)
  * `rotate`
    * 角度
    * 顺时针／逆时针
  * `skew(x, y)`
  * `translate(x, y)`
  * `scale(x, y)`
* css
  * `animate(animateName)`

### 时间线

```then```

### 特点

优点：

> 对于单个物体的简单动画表示很简洁

不足：

> 对于同一时间线多个物体或复杂动画就显得有些吃力
>
> 且出了播放外，不能控制动画

## anime

支持的动画属性有

* object
* css
* css translate
* dom property
* svg property

有bezier, ease

> 使用requestAnimationFrame来驱动动画， 最终调用动画实例的tick方法
>
> ```JavaScript
> // 修改状态的方法  
> const setTweenProgress = {
>     css: (t, p, v) => t.style[p] = v,
>     attribute: (t, p, v) => t.setAttribute(p, v),
>     object: (t, p, v) => t[p] = v,
>     transform: (t, p, v, transforms, id) => {
>       if (!transforms[id]) transforms[id] = [];
>       transforms[id].push(`${p}(${v})`);
>     }
>   }		
> ```
>
> 



## GreenSocks



## 我的思考

### ~~动画~~(动作)的结构

#### ~~动画~~(动作)是物体的一个特性

提供比如说```Object.moveTo(value, time, easing)```类似的接口，里边实现则是在```Object```的类中调用有关的驱动方法，就如```move```库那样

* 要实现同时修改多个属性的话，需要将这些```moveTo```的参数缓存起来，并提供另外一个比如说```play```的接口，否则只能先```moveTo```，然后```rotateTo```，而不能进行同时改变位置和角度的操作。
* 即使能够同时修改多个属性，但一连串的keyframes概念不太好表现出来。```move```是采用```then```或者```end```回调来实现的。

#### ~~动画~~(动作)和物体分开

* 更容易理解
* ~~动画~~(动作)和对象分离，可以单独操作对象，也可以单独操作动画，耦合度更低。
* 可以提供更多的~~动画~~(动作)类型，`sequenceAnimation`, `spawnAnimation`等，而不影响其他模块，扩展更高

> 采用```cocos2d```类似的结构来整合动画对象

### 我们需要什么~~动画~~(动作)

#### 基本~~动画~~(动作)

* 立马生效的动画
  * 显示／隐藏
  * 移除
  * 设置位置，旋转角度等
  * `回调`
* 有过渡时间的~~动画~~(动作)
  * `move to/by`
  * `rotate to/by`
  * `scale to/by`
  * `skew to/by`
  * ...

#### 组合~~动画~~(动作)

* 可以同时改变多个属性的~~动画~~(动作)（`一个keyframe`)
* 可以多个keyframe~~动画~~(动作)组合(`多个keyframes`)
  * 按顺序执行
  * 同时执行

> 因为考虑到简单动画中可以直接调用一个回调方法，这已经超过动画的范围，同时为了以后能支持更多的相似操作（作用于一个对象），所以这儿将之前的动画概念扩展为action(动作)

#### ~~动画~~(动作)驱动的类型

> 这部分的存在，是考虑到web端实现一个动画（用动画做为例子）的方式有多种，有css动画，js动画等，同时也想保留支持多个平台的特性（需要记录有关字段，暂不实现）

* css驱动
  * css transform
  * css animation
* code()驱动
  * dom属性
  * svg属性
* oc驱动
* swift驱动
* ...

##### `问题：如何将driver的信息综合到Action里边?`

* action中提供一个type选项，根据type的值，来执行对应的代码
  * 因为不同的driver需要不同的参数，比如说css transform需要对应的transform property，这些通过一个type并不能解决，并且不好扩展


* action中提供一个driver配置，有type和其他属性
  * 可以扩展
  * 不过有些将所有的逻辑写在了action里边，一堆if
* action中提供一个driver实例
  * 实际的action还是会需要根据不同的driver有不同的属性，比如说，```cssDriver```就需要传递transform property, 而```jsDriver```则不需要
  * 在一个action类中有多个字段，只是因为不同的driver需要，耦合度比较高
* 将css／js等的驱动全部用类继承来表示，如可以有```cssDriverMoveTo```, ```jsDriverMoveTo```这样子存在
  * 相同功能的类过多
  * 每个类功能单一，耦合度低，扩展性好

### 动作

> 对某个对象执行某种操作，称之为Action(动作)

#### 属性

* target：表示执行action的对象

#### 方法

* isDone：是否完成
* startActionWithTarget：执行动作
* update：动作可能需要的更新操作，包括瞬时动作和持续动作的更新逻辑

### 动画的属性

- 时长（duration)
- 反复（loop／repeat)
- 延迟（delay)
- 弹性（ease)
- 复原（reset)

动画的状态

* started
* run
* completed
* reversed
* paused
* ​

> 对于一个物体的动画，链式确实很简洁优雅

将物体的由某个状态```state```／关键帧`keyframe`变成另外一个状态的过程，称为切换动画```SwitchAnimation```。

如物体O有三个状态A，B，C，那么从A->B->C的过程就是由两个动画```Animation```组成，这整个过程称为状态动画```StateAnimation```。

将场景复杂化一些，现在我们有两个物体O1和O2，物体O1有状态动画StateAnimation1，物体O2有状态动画StateAnimation2，现在两物体同时执行各自的状态动画，称为时间线```TimeLine```

所以

> 切换动画和状态动画都是说一个物体的
>
> 时间线是应用于```多个对象```的`状态动画`上的

注：这儿将切换动画和状态动画分离出来只是为了好理解，其实这两者跟关键帧没有任何区别，一个状态就是一个关键帧。



所涉及的对象

* Target

  > 动画的target，接口为
  >
  > ```
  > runAnimation()
  > ```
  >
  > ​

* Action

  > 表示一个最简单的动作，是Animation的基本组成成分。
  >
  > 这个动作可以是
  >
  > ​
  >
  > * 瞬时性动作
  >
  >   * 回调
  >   * 其他
  >
  > * 持续性动作
  >
  >   * 切换动画
  >
  >   ​

* Animation

  > 属性是一个集合，集合中的元素可以是
  >
  > ​
  >
  > * Action。
  > * 另一个Animation
  >
  > 集合中执行的顺序可以是
  >
  > ​
  >
  > * 顺序
  > * 并发
  >
  > ​
  >
  > 接口
  >
  > ```JavaScript
  > // 增，删，查，改
  > addAction()
  > removeAction()
  > findAction()
  > modifyAction()
  >
  > // 动画控制
  > play()
  > stop()
  > restart()
  > seek()
  >
  >
  > // 动画属性的查询
  > ```
  >
  > 回调
  >
  > 考虑到之后从文件中读取相关配置，来驱动动画。而需要执行的具体的回调函数我们并不知道，所以统一改成发送`Notification`的方式。一来比较容易实现，二来分离了这两个（动画和具体的动画回调）的关系，降低了耦合度。
  >
  > ​

