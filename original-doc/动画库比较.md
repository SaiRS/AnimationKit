## Move

> 一个对象的时间线动画
>
> 对象属性设置和动画的属性设置分开

### 关键帧

> 链式构造确实很简洁优雅

* 设置绝对状态(transition)
  * ```set(property, value)```
* 相对于当前状态的该变量(transition)
  * ```add(property, value)```
  * ```sub(property, value)```
* 旋转(transform)
  * `rotate`
    * 角度
    * 顺时针／逆时针
  * `skew(x, y)`
  * `translate(x, y)`
  * `scale(x, y)`
* css
  * `animate(animateName)`

### 时间线

```then```

### 特点

优点：

> 对于单个物体的简单动画表示很简洁

不足：

> 对于同一时间线多个物体或复杂动画就显得有些吃力
>
> 且出了播放外，不能控制动画

## anime

支持的动画属性有

* object
* css
* css translate
* dom property
* svg property

有bezier, ease

> 使用requestAnimationFrame来驱动动画， 最终调用动画实例的tick方法
>
> ```JavaScript
> // 修改状态的方法  
> const setTweenProgress = {
>     css: (t, p, v) => t.style[p] = v,
>     attribute: (t, p, v) => t.setAttribute(p, v),
>     object: (t, p, v) => t[p] = v,
>     transform: (t, p, v, transforms, id) => {
>       if (!transforms[id]) transforms[id] = [];
>       transforms[id].push(`${p}(${v})`);
>     }
>   }		
> ```
>
> 



## GreenSocks



## 我的思考

### ~~动画~~(动作)的结构

#### ~~动画~~(动作)是物体的一个特性

提供比如说```Object.moveTo(value, time, easing)```类似的接口，里边实现则是在```Object```的类中调用有关的驱动方法，就如```move```库那样

* 要实现同时修改多个属性的话，需要将这些```moveTo```的参数缓存起来，并提供另外一个比如说```play```的接口，否则只能先```moveTo```，然后```rotateTo```，而不能进行同时改变位置和角度的操作。
* 即使能够同时修改多个属性，但一连串的keyframes概念不太好表现出来。```move```是采用```then```或者```end```回调来实现的。

#### ~~动画~~(动作)和物体分开

* 更容易理解
* ~~动画~~(动作)和对象分离，可以单独操作对象，也可以单独操作动画，耦合度更低。
* 可以提供更多的~~动画~~(动作)类型，`sequenceAnimation`, `spawnAnimation`等，而不影响其他模块，扩展更高

> 采用```cocos2d```类似的结构来整合动画对象

### 我们需要什么~~动画~~(动作)

#### 基本~~动画~~(动作)

* 立马生效的动画
  * 显示／隐藏
  * 移除
  * 设置位置，旋转角度等
  * `回调`
* 有过渡时间的~~动画~~(动作)
  * `move to/by`
  * `rotate to/by`
  * `scale to/by`
  * `skew to/by`
  * ...

#### 组合~~动画~~(动作)

* 可以同时改变多个属性的~~动画~~(动作)（`一个keyframe`)
* 可以多个keyframe~~动画~~(动作)组合(`多个keyframes`)
  * 按顺序执行
  * 同时执行

> 因为考虑到简单动画中可以直接调用一个回调方法，这已经超过动画的范围，所以这儿将之前的动画概念扩展为action(动作)

### 动作

#### 属性

* 目标对象(target)

#### 方法

* 是否完成(isDone)
* 执行动作
* 动作的更新

### 动画的属性

- 时长（duration)
- 反复（loop／repeat)
- 延迟（delay)
- 弹性（ease)
- 复原（reset)

动画的状态

* started
* run
* completed
* reversed
* paused
* ​

> 对于一个物体的动画，链式确实很简洁优雅

将物体的由某个状态```state```／关键帧`keyframe`变成另外一个状态的过程，称为切换动画```SwitchAnimation```。

如物体O有三个状态A，B，C，那么从A->B->C的过程就是由两个动画```Animation```组成，这整个过程称为状态动画```StateAnimation```。

将场景复杂化一些，现在我们有两个物体O1和O2，物体O1有状态动画StateAnimation1，物体O2有状态动画StateAnimation2，现在两物体同时执行各自的状态动画，称为时间线```TimeLine```

所以

> 切换动画和状态动画都是说一个物体的
>
> 时间线是应用于```多个对象```的`状态动画`上的

注：这儿将切换动画和状态动画分离出来只是为了好理解，其实这两者跟关键帧没有任何区别，一个状态就是一个关键帧。



所涉及的对象

* Target

  > 动画的target，接口为
  >
  > ```
  > runAnimation()
  > ```
  >
  > ​

* Action

  > 表示一个最简单的动作，是Animation的基本组成成分。
  >
  > 这个动作可以是
  >
  > ​
  >
  > * 瞬时性动作
  >
  >   * 回调
  >   * 其他
  >
  > * 持续性动作
  >
  >   * 切换动画
  >
  >   ​

* Animation

  > 属性是一个集合，集合中的元素可以是
  >
  > ​
  >
  > * Action。
  > * 另一个Animation
  >
  > 集合中执行的顺序可以是
  >
  > ​
  >
  > * 顺序
  > * 并发
  >
  > ​
  >
  > 接口
  >
  > ```JavaScript
  > // 增，删，查，改
  > addAction()
  > removeAction()
  > findAction()
  > modifyAction()
  >
  > // 动画控制
  > play()
  > stop()
  > restart()
  > seek()
  >
  >
  > // 动画属性的查询
  > ```
  >
  > 回调
  >
  > 考虑到之后从文件中读取相关配置，来驱动动画。而需要执行的具体的回调函数我们并不知道，所以统一改成发送`Notification`的方式。一来比较容易实现，二来分离了这两个（动画和具体的动画回调）的关系，降低了耦合度。
  >
  > ​